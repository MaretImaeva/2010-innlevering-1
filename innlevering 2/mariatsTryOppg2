#MergeSort:
def MergeSort(A):
    n = len(A)
    if n <= 1:
        return A
    i = (n//2)
    Array1 = MergeSort(A[:i])
    Array2 = MergeSort(A[i:])
    return Merge(Array1, Array2, A)


def Merge(Array1, Array2, A):
    global m_swap, m_comp
    i = 0
    j = 0
    while i < len(Array1) and j < len(Array2):
        m_comp += 1
        if Array1[i] <= Array2[j]:
            A[i+j] = Array1[i]
            i = i + 1
            m_swap += 1
        else:
            A[i+j] = Array2[j]
            j = j + 1
    while i < len(Array1):
        A[i + j] = Array1[i]
        i = i + 1
    while j < len(Array2):
        A[i + j] = Array2[j]
        j = j + 1
    return A
#ferdig mergesort


#Quicksort----------------------------------------------
def ChoosePivot(A, low, high):
    global q_comp, q_swap
    midt= (low + high)//2

    a = A[low]
    b = A[midt]
    c = A[high]

    if (a<= b <=c ) or (c<= b <= a):
        q_comp += 2
        return midt
    elif (b<= a<= c) or (c<= a <= b):
        q_comp +=2
        return low
    else:
        return high


def Partition(A, low, high):
    global q_swap, q_comp
    p = ChoosePivot(A, low, high)
    A[p], A[high] = A[high], A[p]
    q_swap += 1

    pivot = A[high]
    left = low
    right = high - 1

    while left <= right:
        while left <= right and A[left] <= pivot:
            q_comp += 1
            left = left +1
        while right >= left and A[right] >= pivot:
            q_comp += 1
            right = right-1
        if left < right:
            q_swap += 1
            A[left], A[right] = A[right], A[left]
            left+=1
            right-=1
    A[left], A[high] = A[high], A[left]
    q_swap += 1
    return left

def Quicksort(A, low, high):
    global q_swap, q_comp
    if low >= high:
        q_comp += 1
        return A
    p = Partition(A, low, high)
    Quicksort(A, low, p-1)
    Quicksort(A, p+1, high)
    return A
#quicksort end

#BubbleSort----------------------------------------
def BubbleSort(A):
    global b_swap, b_comp
    n = len(A)
    for i in range(n-1):
        for j in range(n-1-i):
            b_comp += 1
            if A[j] > A[j+1]:
                A[j], A[j+1] = A[j+1], A[j]
                b_swap += 1
    return A
#Bubble end

#insertion----------------------------------------
def InsertionSort(A):
    global i_swap, i_comp
    n = len(A)
    for i in range(1, n):
        j = i
        while j > 0 and A[j-1] > A[j]:
            i_comp += 1
            A[j-1], A[j] = A[j], A[j-1]
            i_swap += 1
            j -= 1
        if j > 0:
            i_comp += 1
    return A
#insertion end


import time
import csv

#swap og compare

m_comp = 0
m_swap = 0
q_swap = 0
q_comp = 0
i_comp = 0
i_swap = 0
b_comp = 0
b_swap = 0

i_midl_tid = 0.0
m_midl_tid = 0.0
b_midl_tid = 0.0
q_midl_tid = 0.0

filnavn = input("Vennligst legg ved din fil:\n ")

array = []
with open(filnavn, "r") as f:
    with open(filnavn+"_results.csv", "w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(("n", "merge_cmp", "merge_swaps", "merge_time", "quicksort_cmp", "quicksort_swaps", "quicksort_time", "insert_cmp", "insert_swap", "insert_time", "bubble_cmp", "bubble_swap", "bubble_time"))
        
        lesfil = f.read().split()

        tur = 0
        for line in lesfil:
            m_midl_tid, q_midl_tid, i_midl_tid, b_midl_tid
            #m_timeus, q_timeus, i_timeus, b_timeus
            #m_t, q_t, i_t, b_t
            tur = (tur + 1) % 4

            #m_comp = m_swap = 0
            #q_comp = q_swap = 0
            #i_comp = i_swap = 0
            #b_comp = b_swap = 0

            if tur == 0:
                m_t = time.time_ns()
                m_sortert = MergeSort(array)
                m_timeus = (time.time_ns() - m_t) / 1000
                m_midl_tid += int(m_timeus)
        
            if tur == 1:
                q_t = time.time_ns()
                q_sortert = Quicksort(array, 0, len(array)-1)
                q_timeus = (time.time_ns() - q_t) / 1000
                q_midl_tid += int(q_timeus)

            if tur == 2:
                i_t = time.time_ns()
                i_sortert = InsertionSort(array)
                i_timeus = (time.time_ns() - i_t) / 1000
                i_midl_tid += int(i_timeus)

            if tur == 3:
                b_t = time.time_ns()
                b_sortert = BubbleSort(array)
                b_timeus = (time.time_ns() - b_t) / 1000
                b_midl_tid += int(b_timeus)


            writer.writerow([len(array), m_comp, m_swap, m_midl_tid, q_comp, q_swap, q_midl_tid, i_comp, i_swap, i_midl_tid, b_comp, b_swap, b_midl_tid])

            array.append(int(line))


